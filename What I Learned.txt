Learning Summary Real Project
=========================
-> Fix Dependency Issue
-> Spring Data Rest
-> Web Client Syn and Asyn request
-> Spring security (diff File spring-security & Learning spring security AVAILABLE ON GIT)
-> spring cors Config
-> GetCurrentLoginUser(Git Hub Repo Code Available )
-> Send Simple email by Use Java Mail sender class
-> Liquibase (Search on google for more) as compare only entity
-> Auto add & update Audit Field(create,update) (GIT HUB REPO CODE AVAILABLE & also Cors Config File  ) 



Fix some issue in ide like dependency add but maven not download 
================================================================
Force Maven to update dependencies:
-> mvn clean install -U


=================
Spring Data REST
=================


=> It is used to simplify REST API development

		RestController + JpaRepository = RestRepositoryResource


1) Create Spring starter project with below dependencies

		a) rest-repositories (data-rest)
		b) data-jpa
		c) mysql-connector-j
		d) devtools

2) Configure datasource properties 

3) Create Entity class for table mapping

@Entity
@Table(name = "book_tbl")
public class Book {

	@Id
	private Integer id;
	private String name;
	private Double price;

}

4) Create Rest Repository to expose REST API methods

@RepositoryRestResource(path = "books")
public interface BookRepository extends JpaRepository<Book, Integer>{
	
	public List<Book> findByName(@Param("name") String name);

}

5) Run the application and test it using POSTMAN


-> access localhost:9090/books all crud opration handle means Auto create api for GET,POST,PUT,DELETE

POST : http://localhost:9090/books

{
    "id": 103,
    "name": "DevOps",
    "price": 1500.20
}

PUT : http://localhost:9090/books/103

{
    "id": 103,
    "name": "DevOps",
    "price": 2500.20
}


GET : http://localhost:9090/books

GET : http://localhost:9090/books/101

GET : http://localhost:9090/books/search/findByName?name=Java

DELETE : http://localhost:9090/books/101


========================================================
How to disable HTTP Requests in Data REST application ?
========================================================

=> Add below class in Data REST Application to disable PUT and DELETE methods.

Note: With below configuration our api will not accept PUT and DELETE methods.

------------------------------------------------------------------------
@Configuration
public class MyDataRestConfig implements RepositoryRestConfigurer {
	
	@Override
	public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config, CorsRegistry cors) {

		HttpMethod[] unsupportedMethods = { HttpMethod.PUT, HttpMethod.DELETE };
		
		config.getExposureConfiguration()
			  .forDomainType(Book.class)
			  .withItemExposure((metadata, http) -> http.disable(unsupportedMethods))
			  .withCollectionExposure((metadata,http) -> http.disable(unsupportedMethods));
		
	}
}
-------------------------------------------------------------------------



How to send Async request using WebClient.
==================================================

=> In below class getQuoteV1() method will act as synchronus client and getQuoteV2() method will act as asynchronus client.

-------------------------------------------------------------------------

@Service
public class QuoteService {
	
	private static final String QUOTE_ENDPOINT  = "https://type.fit/api/quotes";
	
	public void getQuoteV2() {
		
		WebClient client = WebClient.create();
		
		 System.out.println("Rest api call started...");
		 	
			client.get()
				  .uri(QUOTE_ENDPOINT)
				  .header("Accept", "application/json")
				  .retrieve()
				  .bodyToMono(String.class)
				  .subscribe(QuoteService::handleResponse);    --------> make async request(not wait)
			
		  System.out.println("Rest api call completed...");
	}
	
	public static void handleResponse(String s) {
		System.out.println(s);
		// logic
	}
	
	public void getQuoteV1() {
		
		WebClient client = WebClient.create();
		
		 System.out.println("Rest api call started...");
		 	
		  Mono<String> bodyToMono = client.get()
					  .uri(QUOTE_ENDPOINT)
				          .retrieve()
					.bodyToMono(String.class);
		  
		  System.out.println(bodyToMono.block());       -------> make sync request(wait)
		  
		  System.out.println("Rest api call completed...");
	}

}

Spring Cors Config
===================

=> Without CorsConfig → frontend on different domain cannot call your backend.
=> With your current CorsConfig → frontend can call backend, but only with manual tokens (no cookies/session-based auth).

 
GetCurrent LoginUser
====================
It is used in real project we cannot take user id from frontend .We get user details from securitycontext
object because in this current user login details available (class & code available in repo)


Java Mail Sender
=====================
>> What your EmailService currently supports

✅ Sending simple text emails (SimpleMailMessage).
✅ Uses the sender email (spring.mail.username) from application.properties / application.yml.
✅ Works fine for sending things like OTPs, account activation links, or simple notifications.
🔹 What it does not support (yet)
❌ HTML emails → If you want styled emails (with buttons, tables, colors), you need MimeMessageHelper.
❌ Attachments → Can’t send PDFs, images, etc. with this class.
❌ Inline images → No embedded logos/pictures inside email body.
❌ Error handling → If the mail server fails (wrong password, blocked, etc.), you don’t catch exceptions here.


Liquibase
===============

🔹 1. Version control for the database
Just like Git tracks code changes, Liquibase tracks DB schema changes.
Every change is stored as a changeSet with a unique ID.
✅ Real-world use: multiple developers can safely add columns, tables, or constraints without overwriting each other’s work.

🔹 2. Safe deployment across environments

Dev, QA, Staging, Prod → all have separate databases.
Liquibase ensures all environments are consistent:
Dev adds a new column → same column appears in QA & Prod automatically.
✅ Avoids errors like “column not found” in production.

🔹 4. Rollback support
Mistake in migration? Liquibase allows you to rollback safely.
Example: Added wrong column → run rollback script → DB restored.

🔹 6. Data seeding / reference data
Liquibase can load initial/reference data from CSV or XML.
Example: Load default roles (ADMIN, USER) when app starts.
✅ No need to write custom scripts manually.

🔹 7. Database-agnostic changes
Liquibase supports multiple databases (MySQL, PostgreSQL, Oracle, SQL Server).
You can write one changeSet → works across all DBs.

✅ Saves time in multi-database projects.
🔹 8. Team collaboration
Multiple developers can safely work on the same project.
Liquibase keeps all schema changes

Only entities → works, fast, okay for small projects.
But for real-world production apps, it’s risky. Using Liquibase or Flyway with entities is the best practice.